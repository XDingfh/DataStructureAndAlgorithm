时间、空间复杂度分析。<font color=red>复杂度分析是算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</font></br>
为什么需要复杂度分析？</br>
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</br>
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</br>
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</br>
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</br>
为什么要进行复杂度分析？</br>
1.与性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</br>
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</br>
<h3大0 复杂度表示法</h3></br>
算法的执行效率，粗略地讲，就是算法代码执行的时间。</br>
所以代码的执行时间T(n) 与每行代码的执行次数 n成正比。</br>
<font color=red> T(n) = O(f(n))</font></br>
T(n) ，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。 公式中的O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</br>
大O时间复杂度表示法，<font color=red>表示代码执行时间随数据规模增大的变化趋势。也叫做渐进时间复杂度，简称时间复杂度。</font></br>
特点:</br>
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以系数、低阶、常量实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</br>
</br>
<h3>时间复杂度分析</h3></br>
&nbsp;&nbsp;1.只关注循环执行次数最多的一段代码</br>
&nbsp;&nbsp;2.加法法则：总复杂度等于量级最大的那段代码的复杂度。</br>
&nbsp;&nbsp;3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</br>
复杂度分析法则</br>
 &nbsp; &nbsp;1）单段代码看高频：比如循环。</br>
 &nbsp; &nbsp;2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</br>
 &nbsp; &nbsp;3）嵌套代码求乘积：比如递归、多重循环等</br>
 &nbsp; &nbsp;4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相</br>
  </br>
几种常见时间复杂度实例分析</br>
<img src='https://github.com/XDingfh/DataStructureAndAlgorithm/blob/master/src/main/resources/images/GeekTime/Analysis1.png'></br>


对于罗列的复杂度量级，我们可以分为两类，多项式量级和非多项式量级。其中非多项式量级只有两个：O(2^n) 和 O(n!).</br>
多项式：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</br>
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）</br>
</br>

<h3>空间复杂度分析</h3></br>
空间复杂度全称就是<font color=red>渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。</font></br>

</br>
内容小结.</br>
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。</br>
</br>
<img src='https://github.com/XDingfh/DataStructureAndAlgorithm/blob/master/src/main/resources/images/GeekTime/Analysis2.png'></br>



复杂度分析的4个概念。</br>
   &nbsp; &nbsp;  1.最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。</br>
   &nbsp; &nbsp;  2.最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。</br>
    &nbsp; &nbsp; 3.平均情况时间复杂度（加权平均时间复杂度或者期望时间复杂度）：用代码在所有情况下执行的次数的加权平均值表示。</br>
   &nbsp; &nbsp;  4.均摊时间复杂度:在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</br>
二、为什么要引入这4个概念？</br>
 &nbsp; &nbsp;1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</br>
  &nbsp;&nbsp;2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</br>
</br>
三、如何分析平均、均摊时间复杂度？</br>
 &nbsp; &nbsp;1.平均时间复杂度</br>
 &nbsp; &nbsp;代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</br>
 &nbsp; &nbsp;2.均摊时间复杂度</br>
 &nbsp; &nbsp;两个条件满足时使用： 
 &nbsp; &nbsp;1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</br>
 &nbsp; &nbsp;2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</br>
